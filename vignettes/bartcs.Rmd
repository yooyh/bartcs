---
title: "Introduction to bartcs"
author: "Yeonghoon Yoo"
output: rmarkdown::html_vignette
bibliography: REFERENCES.bib
link-citations: true
vignette: >
  %\VignetteIndexEntry{Introduction to bartcs}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup}
set.seed(42)
library(bartcs)
```

The __bartcs__ package finds confounders and treatment effect with Bayesian Additive Regression Trees (BART).

## Tutorial with IHDP dataset

This tutorial will use The Infant Health and Development Program (IHDP) dataset. 
The dataset includes 6 continuous and 19 binary covariates with simulated outcome which is a cognitive test score. This dataset was first used by @Hill2011. My version of dataset is the first realization generated by @LouizosEtal2017 and you can find other versions in his [github](https://github.com/AMLab-Amsterdam/CEVAE).

```{r load and fit}
data(ihdp, package = "bartcs")

fit <- single_bart(
  Y               = ihdp$y_factual,
  trt             = ihdp$treatment,
  X               = ihdp[, 6:30],
  num_tree        = 10,
  num_chain       = 4,
  num_post_sample = 100,
  num_burn_in     = 100,
  verbose         = FALSE
)
fit
```

You can get mean and 95% credible interval of average treatment effect (ATE) and possible outcome Y1 and Y0.

## Result

Both `separate_bart()` and `single_bart()` fits multiple MCMC chains. 
`summary()` provides result and Gelman-Rubin statistic to check convergence. 

```{r summary}
summary(fit)
```

## Data Visualization

You can get posterior inclusion probability for each variables.

```{r pip plots}
plot(fit, method = "pip")
```

Since `inclusion_plot()` is a wrapper function of `ggcharts::bar_chart()`,  you can use its arguments for better plot. 

```{r pip plots with options}
plot(fit, method = "pip", top_n = 10)
plot(fit, method = "pip", threshold = 0.5)
```

With `trace_plot()`, you can visually check trace of effects or other parameters.

```{r trace plots eff}
plot(fit, method = "trace")
```

```{r trace plots alpha}
plot(fit, method = "trace", "alpha")
```

## Multi-threading

```{r count omp thread}
count_omp_thread()
```

Check whether OpenMP is supported. You need more than 1 thread for multi-threading. 
Due to overhead of multi-threading, using parallelization will be not effective with small and moderate datasets.
I recommend parallelization for data with size of at least 10,000.

For comparison purpose, I will create dataset with 40,000 rows by bootstrapping from IHDP dataset.
Then, for fast computation, I will set most parameters to 1.

```{r multi-threading performance}
idx  <- sample(nrow(ihdp), 4e4, TRUE)
ihdp <- ihdp[idx, ]

microbenchmark::microbenchmark(
  simple = single_bart(
    Y               = ihdp$y_factual,
    trt             = ihdp$treatment,
    X               = ihdp[, 6:30],
    num_tree        = 1,
    num_chain       = 1,
    num_post_sample = 10,
    num_burn_in     = 0,
    verbose         = FALSE,
    parallel        = FALSE
  ),
  parallel = single_bart(
    Y               = ihdp$y_factual,
    trt             = ihdp$treatment,
    X               = ihdp[, 6:30],
    num_tree        = 1,
    num_chain       = 1,
    num_post_sample = 10,
    num_burn_in     = 0,
    verbose         = FALSE,
    parallel        = TRUE
  ),
  times = 50
)
```

Result show that parallelization gives better result.

## References



